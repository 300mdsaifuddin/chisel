================================================
========== ADAM's BIG ARSE TODO LIST ============
================================================

======== Current Tasks ========
Temp elimination needs to count # uses
Declared references needs to understand scope <= check in high form check
Size of vector type must be non-negative
Check for recursively defined instances
<>
Add Unit Tests for each pass
   Separate passes into discrete chunks
   Push all tests entirely through
   Check after each pass
   write test that checks instance types are correctly lowered
move width inference earlier
Remove Pad
Fix all primops and width inference
Verilog
SeqMem
BlackBoxes
Scaling

======== Verilog Backend Notes ========
* 1) Emit module. No Parameters. Include clk and reset signals
o 2) Emit all declarations (wires,regs)
o 3) Initialize all regs with random values under synthesis
o 4) Emit all connections as assign statements
o 5) Emit assertions under always @ posedge clk, under synthesis
o 6) Emit all register updates:
      if(io_update_valid) begin
         R4 <= io_update_bits_target;
      end
   Note: muxes turn into if/else statements within the always@ block
Notes:
   For now, emit mems as reg with nothing else.
   WritePorts?

   
======== Update Core ==========
Add exmodule
Add vptype
Add readwriteport

======== Check Passes ==========
Well-formed high firrtl 
   Unique names per module
   No name can be a prefix of any other name.
   No nested modules
   Only modules in circuit (no statements or expressions)
   Cannot connect directly to a mem ever
   Subfields are only on bundles, before type inference 
   Can only connect to a Ref or Subfield or Index
   UInt only has positive ints
   No combinational loops
   cannot connect to a pad, or a register. only connct to a reference
   onreset can only handle a register
   all references are declared
   expression in pad must be a ground type
   node's value cannot be a bundle with a flip in it
   mems cannot be a bundle with flips
   2nd arg in dshr/l must be UInt
   pred in conditionally must be of type UInt
After adding dynamic assertions, insert bounds check with accessor expansion
Well-formed low firrtl
   All things only assigned to once
Width inference
   No names
   No Unknowns
   All widths are positive
   Pad's width is greater than value's width
   pad's width is greater than value's width
   connect can connect from big to small??
Check Gender

======== Other Passes ========
; RUN: firrtl -i %s -o %s.flo -x X -p c | tee %s.out | FileCheck %s
; CHECK: Done!

constant folding (partial eval) pass
   Get rid of unnecessary pads
   push pad into literal
common subexpression elimination pass
deadcode elimination
Verilog backend
Eliminate skips

======== Consultations ========
Andrew: Way to keep Array information for backends to avoid code explosion

======== Think About ========
<>
subword accesses
verilog style guide
annotation system
zero-width wires
expanding mems (consider changing defmem to be size, and element type)
Multi-streams for print statements/asserts (Jack)
Consider def female node. (Patrick) 
Talk to palmer/patrick about how writing passes is going to be supported
Figure out how widths propogate for all updated primops (Adam)
Add FIFOs to the IR (Palmer)
Think about supporting generic primops on bundles and vecs (Adam) (wait until front-end more completed)
Union Types
Enums?
Convert to scala
Firrtl interpreter (in scala)

======== Update Spec ========
Look through all primops
change parser to other unknown thing for vptype?
Add optional type to node
add assertions and printfs
cannot connect directly to a mem (loc can never contain a mem)
Front-end needs to guarantee unique names per module.
FIRRTL rule: No name can be a prefix of any other name.
Future questions to address in spec:
   Introduction – motivation, and intended usage
   Philosophical justifications for all constructs
   More introduction for types, e.g. what is a ground type?
   What is a statement? What is an expression? What is a memory? Difference between vector type and memory? What are accessors for?
   Why would I ever write an empty statement? Mainly for use by compiler/passes
   What is a structural element? Duplication?
   Subtracting two unsigned numbers… Should talk to a math guy to figure it out
   What are shift left and shift right operations? HW doesn’t have these concepts. Need justification.
   What is lowered form? What is it for?

======== Pass Ideas ==========
Bounds checks for accessors
Overflow checks for add/add-wrap
Check combinational
Fast C++ where wires/register/instances are predicated
Verilog backend - put stuff in posedge clock, not assign statements, for speedup
Annotate mems with location stuff
Coverage tests, such as statespace or specific instances (like asserts, sort of)
   check all predicates of whens
Generate a ROM, and index with cycle counter, and dynamically check any wire on a given cycle

======== FIRRTL++ =========
Variable size FIFOs
TruthTable node
Custom types? Parameterized Types?

======== Next Layer Components =======
Accelerator with config registers
Schedulable
   Decouple
   Nack
Scheduler

======== Notes ========
Only for MUXES, AS, and __ can width inference go backwards:
  reg r : UInt<5>
  r := MUX(p,UInt<?>(1),UInt<?>(2))
  ==>
  reg r : UInt<5>
  r := MUX(p,UInt<5>(1),UInt<5>(2))


Which ones
Treat everything as just bits - the only operators that should exist are ones that emit different bits
Go through all primops with Andrew
