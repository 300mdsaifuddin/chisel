================================================
========== ADAM's BIG ARSE TODO LIST ============
================================================

======== Current Tasks ========
dlsh,drsh
Add Unit Tests for each pass
<>
Update spec
   
======== Update Core ==========
Add source locaters

======== Check Passes ==========
Well-formed high firrtl 
   Unique names per module
   No name can be a prefix of any other name.
   No nested modules
   Only modules in circuit (no statements or expressions)
   Cannot connect directly to a mem ever
   Subfields are only on bundles, before type inference 
   Can only connect to a Ref or Subfield or Index
   UInt only has positive ints
   No combinational loops
   cannot connect to a pad, or a register. only connct to a reference
   onreset can only handle a register
   all references are declared
   expression in pad must be a ground type
   node's value cannot be a bundle with a flip in it
   mems cannot be a bundle with flips
After adding dynamic assertions, insert bounds check with accessor expansion
Well-formed low firrtl
   All things only assigned to once
Width inference
   No names
   No Unknowns
   All widths are positive
   Pad's width is greater than value's width
   pad's width is greater than value's width

======== Other Passes ========
constant folding (partial eval) pass
   Get rid of unnecessary pads
   push pad into literal
common subexpression elimination pass
deadcode elimination
Verilog backend
Eliminate skips

======== Consultations ========
Stephen:
   width equality
      pin stephen on an example
Patrick: 
   move Infer-Widths to before vec expansion?

======== Think About ========
<>
subword accesses
verilog style guide
naming for split nodes
annotation system
zero-width wires
expanding mems (consider changing defmem to be size, and element type)
Multi-streams for print statements/asserts (Jack)
Consider def female node. (Patrick) 
Talk to palmer/patrick about how writing passes is going to be supported
Figure out how widths propogate for all updated primops (Adam)
Add FIFOs to the IR (Palmer)
Think about supporting generic primops on bundles and vecs (Adam) (wait until front-end more completed)
Union Types
Enums?
Convert to scala
Firrtl interpreter (in scala)

======== Update Spec ========
Add Not to spec
add assertions and printfs
cannot connect directly to a mem (loc can never contain a mem)
Front-end needs to guarantee unique names per module.
FIRRTL rule: No name can be a prefix of any other name.
Future questions to address in spec:
   Introduction – motivation, and intended usage
   Philosophical justifications for all constructs
   More introduction for types, e.g. what is a ground type?
   What is a statement? What is an expression? What is a memory? Difference between vector type and memory? What are accessors for?
   Why would I ever write an empty statement? Mainly for use by compiler/passes
   What is a structural element? Duplication?
   Subtracting two unsigned numbers… Should talk to a math guy to figure it out
   What are shift left and shift right operations? HW doesn’t have these concepts. Need justification.
   What is lowered form? What is it for?

======== Pass Ideas ==========
Bounds checks for accessors
Overflow checks for add/add-wrap
Check combinational
Fast C++ where wires/register/instances are predicated
Verilog backend - put stuff in posedge clock, not assign statements, for speedup
Annotate mems with location stuff
Coverage tests, such as statespace or specific instances (like asserts, sort of)

======== FIRRTL++ =========
Variable size FIFOs
TruthTable node
Custom types? Parameterized Types?

======== Next Layer Components =======
Accelerator with config registers
Schedulable
   Decouple
   Nack
Scheduler

======== Notes ========
Only for MUXES can width inference go backwards:
  reg r : UInt<5>
  r := MUX(p,UInt<?>(1),UInt<?>(2))
  ==>
  reg r : UInt<5>
  r := MUX(p,UInt<5>(1),UInt<5>(2))

