================================================
========== ADAM's BIG ARSE TODO LIST ============
================================================

======== Current Tasks ========
SeqMem
move width inference earlier
Temp elimination needs to count # uses
Declared references needs to understand scope <= check in high form check
Check for recursively defined instances
Names in bundles must be unique
Fix reset scope
Fix firrtl-gen so it is a relative pass, not global state
Add Unit Tests for each pass
   Check after each pass
   write test that checks instance types are correctly lowered
Scaling
Do name-mangling differently, use _xEF or something like that

======== Verilog Backend Notes ========
* 1) Emit module. No Parameters. Include clk and reset signals
o 2) Emit all declarations (wires,regs)
o 3) Initialize all regs with random values under synthesis
o 4) Emit all connections as assign statements
o 5) Emit assertions under always @ posedge clk, under synthesis
o 6) Emit all register updates:
      if(io_update_valid) begin
         R4 <= io_update_bits_target;
      end
   Note: muxes turn into if/else statements within the always@ block
Notes:
   For now, emit mems as reg with nothing else.
   WritePorts?
   
======== Update Core ==========
Add vptype
Add readwriteport

======== Check Passes ==========
High-Firrtl
   No combinational loops
After adding dynamic assertions, insert bounds check with accessor expansion
Well-formed low firrtl
   All things only assigned to once
Width inference
   No names
   No Unknowns
   All widths are positive
   Pad's width is greater than value's width
   pad's width is greater than value's width
   connect can connect from big to small??

======== Other Passes ========
constant folding (partial eval) pass
   Get rid of unnecessary pads
   push pad into literal
common subexpression elimination pass
deadcode elimination

======== Consultations ========
Andrew: Way to keep Array information for backends to avoid code explosion

======== Think About ========
<>
subword accesses
verilog style guide
annotation system
zero-width wires
expanding mems (consider changing defmem to be size, and element type)
Multi-streams for print statements/asserts (Jack)
Consider def female node. (Patrick) 
Talk to palmer/patrick about how writing passes is going to be supported
Figure out how widths propogate for all updated primops (Adam)
Add FIFOs to the IR (Palmer)
Think about supporting generic primops on bundles and vecs (Adam) (wait until front-end more completed)
Union Types
Enums?
Convert to scala
Firrtl interpreter (in scala)

======== Update Spec ========
Look through all primops
change parser to other unknown thing for vptype?
Add optional type to node
add assertions and printfs
cannot connect directly to a mem (loc can never contain a mem)
Front-end needs to guarantee unique names per module.
FIRRTL rule: No name can be a prefix of any other name.
Future questions to address in spec:
   Introduction – motivation, and intended usage
   Philosophical justifications for all constructs
   More introduction for types, e.g. what is a ground type?
   What is a statement? What is an expression? What is a memory? Difference between vector type and memory? What are accessors for?
   Why would I ever write an empty statement? Mainly for use by compiler/passes
   What is a structural element? Duplication?
   Subtracting two unsigned numbers… Should talk to a math guy to figure it out
   What are shift left and shift right operations? HW doesn’t have these concepts. Need justification.
   What is lowered form? What is it for?

======== Pass Ideas ==========
Bounds checks for accessors
Overflow checks for add/add-wrap
Check combinational
Fast C++ where wires/register/instances are predicated
Verilog backend - put stuff in posedge clock, not assign statements, for speedup
Annotate mems with location stuff
Coverage tests, such as statespace or specific instances (like asserts, sort of)
   check all predicates of whens
Generate a ROM, and index with cycle counter, and dynamically check any wire on a given cycle

======== FIRRTL++ =========
Variable size FIFOs
TruthTable node
Custom types? Parameterized Types?

======== Next Layer Components =======
Accelerator with config registers
Schedulable
   Decouple
   Nack
Scheduler

======== Notes ========
Only for MUXES, AS, and __ can width inference go backwards:
  reg r : UInt<5>
  r := MUX(p,UInt<?>(1),UInt<?>(2))
  ==>
  reg r : UInt<5>
  r := MUX(p,UInt<5>(1),UInt<5>(2))


Which ones
Treat everything as just bits - the only operators that should exist are ones that emit different bits
Go through all primops with Andrew
